HardScope compiler extension
============================

This repository contains the HardScope GCC extension source code and test
framework for HardScope.

The HardScope GCC plug-in performs analysis of a C-program and stores the
analysis data in GCC target machine specific data structures. This plug-in
version targets GCC 6.1.0.

## Files

    ├── README.md             : This README file
    ├── Makefile              : Project Makefile
    ├── gcc-plugin            : GCC plug-in source
    ├── include/xscen.h       : C macros for xscen annotations
    ├── bare                  : RISC-V / Pulpino platform files
    ├── scripts               : Utility scripts
    ├── tests                 : Directory containing the test cases
    ├── tests/all_tests.sh    : Script to run all tests
    ├── tests/compile_test.sh : Script to compile test case
    ├── LICENSE.apache        : License for scripts and tests
    ├── LICENSE.gpl3          : License for gcc-plugin
    └── LICENSE.solderpad     : License for pulpino platform files

## Obtaining and Building the Toolchain

HardScope requires a modified RISC-V toolchain with support for the HardScope
instruction set extension (`xscen`). The modified RISC-V toolchain can be
obtained by cloning the HardScope fork of the `riscv-tools` repository at GitHub:

    $ git clone https://github.com/runtime-scope-enforcement/riscv-tools.git
    $ cd riscv-tools
    $ git submodule update --init --recursive

The following packages are required to build RISC-V toolchain on Ubuntu or other
Debian derived Linux distributions:

autoconf automake autotools-dev curl device-tree-compiler libmpc-dev libmpfr-dev
libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc
zlib1g-dev

Requirements for other systems may be different. Refer to RISC-V toolchain
documentation for more information. To build the modified RISC-V toolchain set
the `RISCV` environment variable to the destination path where the toolchain
should be installed, and run the `build-rv32ima.sh` script in the `riscv-tools`
directory:

    $ cd riscv-tools
    $ export RISCV=$HOME/riscv-hdscope 
    $ ./build-rv32ima.sh

The testsuite (see below) also requires a version of Spike, the RISC-V ISA
Simulator built with support for the Pulpino memory map. A suitable version of
spike can be built using the `build-spike-pulp.sh` script located in the
`riscv-tools` directory:

    $ cd riscv-tools
    $ export RISCV=$HOME/riscv-hdscope
    $ ./build-spike-pulp.sh

The executable, `spike-pulp` will be installed at `$RISCV/bin/spike-pulp`.

## GCC Plug-in

The HardScope _scope enforcement_ (`scen`) plug-in performs analysis on
higher-level passes on the GCC GIMPE intermediate representation and stores the
relevant information in the `cfun->machine` structure. The modified RISC-V
compiler backend is has been extended to augment needed functions by emitting
the extra `xscen` instructions based on the analysis results generated by the
plug-in.

Once the modified toolchain has been sucessfully built as per above, the
HardScope GCC Plug-in can be built by running `make plugin` in the
`hardscope-tools` repository:

    $ cd hardscope-tools
    $ make plugin
    
GCC plug-ins are loaded with the the `-fplugin` option on the command line. A
HardScope enabled program can be built with the modified toolchain and plug-in
as follows:

    $ $RISCV/bin/riscv32-unknown-elf-gcc -mxscen -fplugin=./gcc-plugin/scen.so -Xassembler -march=rv32imxscen myprogram.c

### Finding globals

Use of global variables can be determined by walking the GIMPLE tree of each
function. In the GIMPLE tree, each function's basic blocks (BB) and their
statements are iterated through and a check is performed for each operand to
determine if it's a global. The result is a set of `VAR_DECL` tree nodes.

The Register Transfer Language (RTL) representation of a tree node can be
recovered with the `DECL_RTL` macro. For `VAR_DECL` we can find all memory
objects which have `symbol_ref` as their first operand.

To successfully load a symbol in RISC-V, `riscv_legitimize_move` can be called
with register as the destination and `SYMBOL_REF` as a source.

### Constant strings

Constant strings are not shown as global variables. When they are used, the tree
node  contains an `ADDR_EXPR` with `STRING_CST` as its only operand. From
`STRING_CST` a RTL fragment can be generated or found via `output_constant_def`.
The `mem` that is returned, can be used in the same manner as other globals.

### Global string pointers

There are global string pointers that are initialized with immediate `const`
string. Use of these string pointers can be detected, but because their values
may change it's not enough to rely on the initialization value.

### Pointer argument delegation

Pointer arguments must be delegated on call-site with `srdlg`. The current
approach iterates `DECL_ARGUMENTS(cfun->decl)` for each function in the plug-in.
On call-site in function `riscv_expand_call` callee's `struct function` is not
available easily, only the rtx destination address of the call.

From expression-pointer (RTX) `addr` we can access `tree` and its field
`function_decl`, but field `struct function *f` is null. It seems that the
struct is cleared before the expand pass is executed. As a workaround we
currently store function call UIDs and corresponding "delegation" vectors to
caller's `struct function`, field `callee_pointer_args` and `callee_uids` in the
analysis phase. UIDs are associated with function declarations, function pointer
calls do not have them. Instead we assign function pointer calls new UIDs
starting from 1. In `riscv_expand_call` resolve the `tree` object of the call
and `uid` of its function declaration and generate a `call_site_delegate` object
holding the `uid`. For function pointer calls, `tree` is not available, so we
just use the assigned UIDs in order. This is probably fragile and could be
improved upon in future versions.

In the generation phase the `uid` that was received as an argument is used to do
a looked up from `cfun->callee_pointer_args` array. The bitmap found is mapped
to argument registers and `srdlg` is applied to them.  Only `decl`s, `label`s
and `type`s seem to have `uid`s

An extra pass at some later point could be more practical and reliable.
Requirements (or wishes) for this pass would be access to GIMPLE, access to RTL,
and `struct function *f` intact. Another approach could be looking into
`INSN_LOCATION` and see if it could identify calls.

### Returned pointers

Pointer returning logic is completely in the backend for now. In
`riscv_function_value`, the return value is checked with `POINTER_TYPE_P` and
the register where the value is returned, is marked to
`cfun->machine->returns_pointer`.  Epilogue delegation checks this value and
emits delegation instruction if it's set.

### Switch-case jump table

Functions with switch statements use jump tables to jump to the correct label.
Jump tables are arrays of code addresses.  GCC tree representation has
`SWITCH_EXPR` for switch statements. GIMPLE uses `gswitch` statements. From them
it's possible to get the labels and indices.  RTL dispatch tables like
`jump_table_data` are constructed in `stmt.c` and `emit-rtl.c`. `expand_case` is
the function that essentially does this based on a `gswitch`.  Editing
`emit-rtl` and `emit_jump_table_data` could be possible.

Maybe this requires a new pass after the jump table has been generated that
iterates through function RTL and finds `JUMP_TABLE_DATA` RTXs. However, this
happens during `expand` and after that the RTL is not trivially modifiable
any longer.

The `tablejump` and `casesi` patterns are defined in machine descriptions, these
contain the jumps and the table label. `tablejump_p` finds the `jump_table_data`
from a table jump RTX. With `rtx_jump_table_data` we get real number of
generated labels. 

In machine desription `define_expand tablejump` we call function
`riscv_xscen_register_jumptable` that updates the `cfun->machine->jumptable` by
setting it to the `code_label` and `jtcount`.  During prologue expansion,
`riscv_xscen_prologue` is called and then we have the jump table ready.  It can
now be accessed with the `tablejump_p` using the label that was stored earlier.
True number of labels can be retrieved from `rtx_jump_table_data` structure and
the size of the table then calculated by multiplying it with the pointer size.

## Tests

Tests are located in directory tests. The `all_tests.sh` script can be used to
run them.  Each test is a C-source file with its name prefixed with `test_` Some
tests use helper files as well. These are named `testhelp_testname.c`.

By default, tests are expected to return 0 on success. For negative test cases
and other reasons, the expected return values can be defined in `all_tests.sh`.

The test consists of four phases: a compile and spike-run for default spike and
for spike-pulp.  Both, spike and spike-pulp, must be in PATH for execution to
succeed.  Regression is tracked by writing the name of the test for every
successful execution.  If execution of the test fails at any point in the
future, it will be marked as a regression fail.

### Disclaimer & Known issues

All implementations are only research prototypes!

Our code is NOT safe for production use! Please use it only for experiments. 

The analysis extension is tested against CoreMark. It may crash while
instrumenting arbitrary C programs.

All tests are functional, but not supported by the compiler at the moment.

## License

GCC Plug-in is licensed under the GPLv3 License:

     Copyright 2018 Aalto University, Secure Systems Group

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.


The RISC-V platform files are licenced under the 3-Clause BSD License:

    Copyright (C) 2010-2017, The Regents of the University of California.
    Copyright (C) 2018 Aalto University, Secure Systems Group

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:

    1. Redistributions of source code must retain the above copyright
       notice, this list of conditions and the following disclaimer.

    2. Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.

    3. Neither the name of the copyright holder nor the
       names of its contributors may be used to endorse or promote products
       derived from this software without specific prior written permission.

    IN NO EVENT SHALL THE COPYRIGHT HOLDERS AND CONTRIBUTORS BE LIABLE TO ANY
    PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES,
    INCLUDING LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
    DOCUMENTATION, EVEN IF HE COPYRIGHT HOLDERS AND CONTRIBUTORS HAVE BEEN
    ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

    HE COPYRIGHT HOLDERS AND CONTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
    INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
    FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION,
    IF ANY, PROVIDED HEREUNDER IS PROVIDED "AS IS". HE COPYRIGHT HOLDERS AND
    CONTRIBUTORS HAVE NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
    ENHANCEMENTS, OR MODIFICATIONS.


Pulpino platform files are licensed under the Solderpad Hardware License:

     Copyright 2016 ETH Zurich and University of Bologna.
     Copyright 2018 Aalto University, Secure Systems Group

    Copyright and related rights are licensed under the Solderpad Hardware
    License, Version 0.51 (the “License”); you may not use this file except in
    compliance with the License. You may obtain a copy of the License at
    http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
    or agreed to in writing, software, hardware and materials distributed under
    this License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR
    CONDITIONS OF ANY KIND, either express or implied. See the License for the
    specific language governing permissions and limitations under the License.


Tests and scripts are licensed under the Apache License:

     Copyright 2018 Aalto University, Secure Systems Group

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    
